https://www.golinuxcloud.com/openssl-create-certificate-chain-linux

Openssl create certificate chain requires Root CA and Intermediate certificate, In this article I will share Step-by-Step Guide to create root and intermediate certificates and then use these certificates to create certificate CA bundle in Linux. I hope you have an overview of all the terminologies used with OpenSSL.

Root vs Intermediate Certificate
A certificate chain or certificate CA bundle is a sequence of certificates, where each certificate in the chain is signed by the subsequent certificate.
The Root CA is the top level of certificate chain while intermediate CAs or Sub CAs are Certificate Authorities that issue off an intermediate root.
Typically, the root CA does not sign server or client certificates directly.
The root CA is only ever used to create one or more intermediate CAs, which are trusted by the root CA to sign certificates on their behalf. This is best practice.
It allows the root key to be kept offline and unused as much as possible, as any compromise of the root key is disastrous.
An intermediate certificate authority (CA) is an entity that can sign certificates on behalf of the root CA.
The root CA signs the intermediate certificate, forming a chain of trust.
The purpose of using an intermediate CA is primarily for security.
The root key can be kept offline and used as infrequently as possible.
If the intermediate key is compromised, the root CA can revoke the intermediate certificate and create a new intermediate cryptographic pair.

Step 1: Create OpenSSL Root CA directory structure
We can also create CA bundle with all the certificates without creating any directory structure and using some manual tweaks but let us follow the long procedure to better understanding. In RHEL/CentOS 7/8 the default location for all the certificates are under /etc/pki/tls. But for this article we will create a new directory structure /root/myCA/ to store our certificates.

Create a directory structure to store the CA files, certificates, and private keys:

bash

mkdir -p ~/myCA/rootCA/{certs,crl,newcerts,private,csr}
mkdir -p ~/myCA/intermediateCA/{certs,crl,newcerts,private,csr}

Each directory in your Certificate Authority (CA) folder structure serves a specific purpose:

certs: This directory contains the certificates generated and signed by the CA. For the root CA, this includes the root CA certificate itself. For the intermediate CA, this includes the intermediate CA certificate and any server or client certificates signed by the intermediate CA.
crl: The Certificate Revocation List (CRL) directory contains the CRLs generated by the CA. A CRL is a list of certificates that have been revoked by the CA before their expiration date.
newcerts: This directory stores a copy of each certificate signed by the CA, with the certificate's serial number as the file name. It helps maintain a backup of all issued certificates.
private: This directory contains the private keys for the CA, including the root CA and intermediate CA private keys. These keys are used to sign certificates and CRLs. The private keys should be kept secure and not shared.

The majority of the files that the CA uses are visible to anyone on the system or at least to anyone who makes any use of the certificates issued by our CA. The one notable exception is the CA certificate’s private key. The private key should never be disclosed to anyone not authorized to issue a certificate or CRL from our CA. The private key should be stored in hardware, or at least on a machine that is never put on a network
A serial file is used to keep track of the last serial number that was used to issue a certificate. It’s important that no two certificates ever be issued with the same serial number from the same CA. OpenSSL is somewhat quirky about how it handles this file. It expects the value to be in hex, and it must contain at least two digits. By setting the initial value to 1000, we ensure that the serial numbers start from 1000 and increment for each subsequent certificate issued.

bash

<!-- echo 1000 > ~/myCA/rootCA/serial
echo 1000 > ~/myCA/intermediateCA/serial -->

mkdir -p ~/src/linux-utils/crypto/certificates/CA/rootCA/{certs,crl,newcerts,private,csr}
mkdir -p ~/src/linux-utils/crypto/certificates/CA/intermediateCA/{certs,crl,newcerts,private,csr}

Each directory in your Certificate Authority (CA) folder structure serves a specific purpose:

certs: This directory contains the certificates generated and signed by the CA. For the root CA, this includes the root CA certificate itself. For the intermediate CA, this includes the intermediate CA certificate and any server or client certificates signed by the intermediate CA.
crl: The Certificate Revocation List (CRL) directory contains the CRLs generated by the CA. A CRL is a list of certificates that have been revoked by the CA before their expiration date.
newcerts: This directory stores a copy of each certificate signed by the CA, with the certificate's serial number as the file name. It helps maintain a backup of all issued certificates.
private: This directory contains the private keys for the CA, including the root CA and intermediate CA private keys. These keys are used to sign certificates and CRLs. The private keys should be kept secure and not shared.

The majority of the files that the CA uses are visible to anyone on the system or at least to anyone who makes any use of the certificates issued by our CA. The one notable exception is the CA certificate’s private key. The private key should never be disclosed to anyone not authorized to issue a certificate or CRL from our CA. The private key should be stored in hardware, or at least on a machine that is never put on a network

A serial file is used to keep track of the last serial number that was used to issue a certificate. It’s important that no two certificates ever be issued with the same serial number from the same CA. OpenSSL is somewhat quirky about how it handles this file. It expects the value to be in hex, and it must contain at least two digits. By setting the initial value to 1000, we ensure that the serial numbers start from 1000 and increment for each subsequent certificate issued.

echo 1000 > ~/src/linux-utils/crypto/certificates/CA/rootCA/serial
echo 1000 > ~/src/linux-utils/crypto/certificates/CA/intermediateCA/serial

A crlnumber is a configuration directive specifying the file that contains the current CRL number. The CRL number is a unique integer that is incremented each time a new Certificate Revocation List (CRL) is generated. This helps in tracking the latest CRL issued by the CA and ensuring that CRLs are issued in a proper sequence. We have given a random digit in our crlnumber file which will be used to keep track of all certs which are revocated.

echo 0100 > ~/src/linux-utils/crypto/certificates/CA/rootCA/crlnumber 
echo 0100 > ~/src/linux-utils/crypto/certificates/CA/crlnumber

Next we will create index.txt file which is a database of sorts that keeps track of the certificates that have been issued by the CA. Each line in the index.txt file represents a certificate and contains information such as the certificate's status (e.g., valid, revoked), the certificate's expiration date, the certificate's serial number, and the certificate subject's distinguished name (DN).

Since no certificates have been issued at this point and OpenSSL requires that the file exist, we’ll simply create an empty file.

touch ~/src/linux-utils/crypto/certificates/CA/rootCA/index.txt
touch ~/src/linux-utils/crypto/certificates/CA/intermediateCA/index.txt

# Step 2: Configure openssl.cnf for Root and Intermediate CA Certificate
<!-- https://www.phildev.net/ssl/opensslconf.html -->
We will create 2 separate openssl.cnf file (each for root and intermediate CA).
Here is our openssl_root.cnf file:

If you are planning to add more intermediate CA certificate then I would recommend to give either a higher value for pathlen or just remove it in the following section. As pathlen restricts creating any further intermediate CA in the chain. You may also create another section v3_intermediate_ca_n and there you can add pathlen: 0 to make sure that is the last intermediate certificate in your chain.
# Note:
This CA certificate tree has been copied to /home/brent.

https://www.golinuxcloud.com/openssl-create-certificate-chain-linux

# Step 3: Generate the root CA key pair and certificate

Create an RSA key pair for the root CA without a password:

bash
pushd ~/CA
openssl genrsa -des3 -passout file:mypass.enc -out ~/CA/rootCA/private/ca.key.pem 4096
chmod 400 ~/CA/rootCA/private/ca.key.pem

If this key is compromised, the integrity of your CA is compromised, which essentially means that any certificates issued, whether they were issued before the key was compromised or after, can no longer be trusted.

We will use openssl command to view the content of private key:
bash
openssl rsa -noout -text -in ~/CA/rootCA/private/ca.key.pem -passin file:mypass.enc
chmod 444 ~/CA/rootCA/private/ca.key.pem
# Create the root CA certificate:
OpenSSL create certificate chain "requires" Root and Intermediate Certificate. In this step you'll take the place of VeriSign, Thawte, etc.
Use the Root CA key ca.key.pem to create a Root CA certificate cacert.pem
Give the root certificate a long expiry date. Once the root certificate expires, all certificates signed by the CA become invalid.
Whenever you use the openssl req tool, you must specify a configuration file to use with the -config option, otherwise OpenSSL will default to /etc/pki/tls/openssl.cnf
We will use v3_ca extensions to create CA certificate

The Common Name (CN) of the CA and the Server certificates must NOT match or else a naming collision will occur and you'll get errors later on.

Use below command to create Root Certificate Authority Certificate cacert.pem. I have specified the Subj inline to the same command, you can update the command based on your environment.

bash
<!-- https://www.phildev.net/ssl/opensslconf.html -->
openssl req -config openssl_root.cnf -key ~/CA/rootCA/private/ca.key.pem -new -x509 -days 7300 -sha256 -extensions v3_ca -out ~/CA/rootCA/certs/ca.cert.pem -subj "/C=US/ST=Michigan/L=Fruitport/O=Mobex Global/OU=Information Systems/CN=Root CA" -passin file:mypass.enc

The CA certificate can be world readable so that it can be used to sign the cert by anyone.

bash

chmod 444 ~/CA/rootCA/certs/ca.cert.pem

Execute the below command for openssl verify root CA certificate
bash
openssl x509 -noout -text -in ~/CA/rootCA/certs/ca.cert.pem

The output shows:

the Signature Algorithm used
the dates of certificate Validity
the Public-Key bit length
the Issuer, which is the entity that signed the certificate
the Subject, which refers to the certificate itself

The Issuer and Subject are identical as the certificate is self-signed.
The output also shows the X509v3 extensions. We applied the v3_ca extension, so the options from [ v3_ca ] should be reflected in the output.

OpenSSL create certificate chain [Root & Intermediate CA]

# Step 4: Generate the intermediate CA key pair and certificate
Create an RSA key pair for the intermediate CA without a password and secure the file by removing permissions to groups and others:

bash

openssl genrsa -out ~/CA/intermediateCA/private/intermediate.key.pem 4096
chmod 400 ~/CA/intermediateCA/private/intermediate.key.pem

Create the intermediate CA certificate signing request (CSR). If you are not familiar with the content to be provided with CSR then you should read Things to consider when creating CSR with OpenSSL

bash

openssl req -config openssl_intermediate.cnf -key ~/CA/intermediateCA/private/intermediate.key.pem -new -sha256 -out ~/CA/intermediateCA/certs/intermediate.csr.pem -subj "/C=US/ST=Michigan/L=Fruitport/O=Mobex Global/OU=Information Systems/CN=Intermediate CA" -passin file:mypass.enc

Sign the intermediate CSR with the root CA key:
bash
openssl ca -config openssl_root.cnf -extensions v3_intermediate_ca -days 3650 -notext -md sha256 -in ~/CA/intermediateCA/certs/intermediate.csr.pem -out ~/CA/intermediateCA/certs/intermediate.cert.pem -passin file:mypass.enc

...
1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated

Assign 444 permission to the CRT to make it readable by everyone:
bash
chmod 444 ~/CA/intermediateCA/certs/intermediate.cert.pem

The index.txt file is where the OpenSSL ca tool stores the certificate database. Do not delete or edit this file by hand. It should now contain a line that refers to the intermediate certificate.

bash
# cat ~/CA/rootCA/index.txt
V 330503082700Z 1000 unknown /C=US/ST=California/O=Example Corp/OU=IT Department/CN=Intermediate CA

Here,

V: This field indicates the status of the certificate. In this case, V means "Valid." Other possible values are R for "Revoked" and E for "Expired."
330503082700Z: This field represents the expiration date of the certificate in the format YYMMDDHHMMSSZ. In this example, the certificate will expire on 30th May 2033 at 08:27:00 UTC.
1000: This field is the certificate serial number in hexadecimal format.
unknown: This field shows the revocation reason if the certificate has been revoked. For valid certificates, this field usually contains the value "unknown" or is left empty.
/C=US/ST=California/O=Example Corp/OU=IT Department/CN=Intermediate CA: This field contains the subject's distinguished name (DN) in the certificate, which consists of various components such as country (C), state or province (ST), organization (O), organizational unit (OU), and common name (CN). In this example, the DN components are as follows:
C: US
ST: California
 

O: Example Corp
OU: IT Department
CN: Intermediate CA

Verify the Intermediate CA Certificate content
bash
openssl x509 -noout -text -in ~/CA/intermediateCA/certs/intermediate.cert.pem

Next openssl verify intermediate certificate against the root certificate. An OK indicates that the chain of trust is intact.

bash
openssl verify -CAfile ~/CA/rootCA/certs/ca.cert.pem ~/CA/intermediateCA/certs/intermediate.cert.pem

/home/brent/CA/intermediateCA/certs/intermediate.cert.pem: OK

# Step 5: Generate OpenSSL Create Certificate Chain (Certificate Bundle)
To openssl create certificate chain (certificate bundle), concatenate the intermediate and root certificates together.

In the below example I have combined my Root and Intermediate CA certificates to openssl create certificate chain in Linux. We will use this file later to verify certificates signed by the intermediate CA.

bash
cat ~/CA/intermediateCA/certs/intermediate.cert.pem ~/CA/rootCA/certs/ca.cert.pem > ~/CA/intermediateCA/certs/ca-chain.cert.pem


After openssl create certificate chain, to verify certificate chain use below command:
bash
openssl verify -CAfile ~/CA/intermediateCA/certs/ca-chain.cert.pem ~/CA/intermediateCA/certs/intermediate.cert.pem

/home/brent/CA/intermediateCA/certs/intermediate.cert.pem: OK


# Step 6: Generate and sign server certificate using Intermediate CA
Create a private key for the server:
bash
openssl genpkey -algorithm RSA -out ~/CA/intermediateCA/private/frt-kors43.busche-cnc.com.key.pem
chmod 400 ~/CA/intermediateCA/private/frt-kors43.busche-cnc.com.key.pem

# Create a certificate signing request (CSR) for the server:
bash
openssl req -config ~/CA/openssl_intermediate.cnf -key ~/CA/intermediateCA/private/frt-kors43.busche-cnc.com.key.pem -new -sha256 -out ~/CA/intermediateCA/csr/frt-kors43.busche-cnc.com.csr.pem
# or
You can automate the certificate signing request (CSR) creation by supplying default answers to the questions asked by the openssl req command.
ALSO READ:
OpenSSL create self signed certificate Linux with example
These defaults can be specified in the openssl.cnf (or openssl_intermediate.cnf in this case) file, under the [ req_distinguished_name ] section.
bash
[ req_distinguished_name ]
countryName_default = US
stateOrProvinceName_default = California
localityName_default = San Francisco
0.organizationName_default = Example Corp
organizationalUnitName_default = IT Department
commonName_default = www.example.com
emailAddress_default = admin@example.com
By including these lines in your openssl_intermediate.cnf file, openssl req will use these as the default values for the corresponding fields, allowing the command to be run non-interactively.
Then, you can use the -batch option with openssl req command to automatically use these defaults without prompting for them:
bash
openssl req -config ~/myCA/openssl_intermediate.cnf -key ~/CA/intermediateCA/private/frt-kors43.busche-cnc.com.key.pem -new -sha256 -out ~/CA/intermediateCA/csr/frt-kors43.busche-cnc.com.csr.pem -batch

# Sign the server CSR with the intermediate CA:
bash
openssl ca -config ~/CA/openssl_intermediate.cnf -extensions server_cert -days 375 -notext -md sha256 -in ~/CA/intermediateCA/csr/frt-kors43.busche-cnc.com.csr.pem -out ~/CA/intermediateCA/certs/frt-kors43.busche-cnc.com.cert.pem

1 out of 1 certificate requests certified, commit? [y/n]y
Write out database with 1 new entries
Data Base Updated

# Verify the server certificate:
bash
openssl x509 -noout -text -in ~/CA/intermediateCA/certs/frt-kors43.busche-cnc.com.cert.pem

openssl verify -CAfile ~/CA/intermediateCA/certs/ca-chain.cert.pem ~/CA/intermediateCA/certs/frt-kors43.busche-cnc.com.cert.pem
/home/brent/CA/intermediateCA/certs/frt-kors43.busche-cnc.com.cert.pem: OK


https://crt.sh/lintcert
paste root certificate:

cablint	NOTICE	CA certificates without Digital Signature do not allow direct signing of OCSP responses
cablint	INFO	CA certificate identified
x509lint	INFO	Checking as root CA certificate
zlint	NOTICE	Root and Subordinate CA Certificates that wish to use their private key for signing OCSP responses will not be able to without their digital signature set

paste intermediate certificate:



# Bonus Tip: Signing and Revoking a certificate using Intermediate CA

# Create a Server Certificate with x509 extensions
This is more complex and shows how to use x509 extensions to distinguish between client and server certificates. It also signs the CSR using the CA bundle.
https://www.golinuxcloud.com/openssl-create-client-server-certificate#Configure_openssl_x509_extensions_for_client_certificate

OpenSSL create server certificate
Next we will create server certificate using openssl.

